<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>TNTN Path Planner</title>
  <link href="https://fonts.googleapis.com/css2?family=Shantell+Sans:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Shantell Sans', cursive;
      text-align: center;
      margin: 0;
      padding: 5vh 2vw;
      background-color: #1a1a1a;
      color: #33ff33;
      height: 100vh;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    h1 {
      color: #33ff33;
      font-size: clamp(2em, 6vw, 4em); /* Responsive with min and max limits */
      margin: 2vh 0;
      font-weight: 700;
    }
    p {
      color: #66ff66;
      font-size: clamp(1em, 2.5vw, 1.5em); /* Responsive with min and max limits */
      margin: 1vh 0;
    }
    img {
      display: none; /* Hide the original img since we'll use canvas */
    }
    canvas {
      border: 2px solid #33ff33;
      cursor: crosshair;
      margin: 2vh 0;
      max-width: 90vw;
      max-height: 60vh;
    }
    .canvas-container {
      position: relative;
      display: inline-block;
    }
    
    #coordinates {
      position: absolute;
      top: 96.5%;
      left: 0;
      font-family: 'Shantell Sans', monospace;
      font-size: clamp(1em, 2.5vw, 1.5em); /* Same responsive sizing as paragraphs */
      margin: 0;
      color: #33ff33;
      white-space: nowrap;
    }
    .controls {
      margin: 2vh 0;
    }
    button {
      margin: 0 1vw;
      padding: 1vh 2vw;
      font-size: clamp(0.8em, 2vw, 1em);
      font-family: 'Shantell Sans', cursive;
      background-color: #2d4a2d;
      color: #33ff33;
      border: 2px solid #33ff33;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    button:hover {
      background-color: #33ff33;
      color: #1a1a1a;
    }
    @media (max-width: 600px) {
      h1 { font-size: 8vw; }
      p { font-size: 4vw; }
      img { width: 80vw; }
      button { padding: 2vh 3vw; }
    }
    
    /* For very large screens */
    @media (min-width: 1920px) {
      h1 { font-size: 4em; }
      p { font-size: 1.5em; }
      img { width: 800px; }
    }
  </style>
</head>
<body>
  <h1>Cubic Bezier Path Planner</h1>
  
  <div class="canvas-container">
    <canvas id="pathCanvas" width="800" height="600"></canvas>
    <img id="backgroundImage" src="VURC.png" alt="VURC Push Back Field" style="display: none;">
    <div id="coordinates">
      Coordinates: (0, 0)
    </div>
  </div>
  
  <div class="controls">
    <button onclick="clearCanvas()">Clear Path</button>
    <button onclick="exportPath()">Export Path</button>
  </div>
  
  <p>Click to set control points for your bezier curve path</p>

  <script>
    // Canvas setup
    const canvas = document.getElementById('pathCanvas');
    const ctx = canvas.getContext('2d');
    const backgroundImg = document.getElementById('backgroundImage');
    const coordinatesDiv = document.getElementById('coordinates');
    
    let controlPoints = [];
    let isDrawing = false;
    let isDragging = false;
    let dragPointIndex = -1;
    let dragOffset = {x: 0, y: 0};
    
    // Load and draw background image
    backgroundImg.onload = function() {
      // Resize canvas to match image aspect ratio
      const aspectRatio = backgroundImg.naturalWidth / backgroundImg.naturalHeight;
      const maxWidth = Math.min(window.innerWidth * 0.8, 1000);
      const maxHeight = Math.min(window.innerHeight * 0.6, 700);
      
      if (maxWidth / aspectRatio <= maxHeight) {
        canvas.width = maxWidth;
        canvas.height = maxWidth / aspectRatio;
      } else {
        canvas.height = maxHeight;
        canvas.width = maxHeight * aspectRatio;
      }
      
      redrawCanvas();
    };
    
    // Trigger image load
    backgroundImg.src = backgroundImg.src;
    
    function redrawCanvas() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw background image
      ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
      
      // Draw control points
      drawControlPoints();
      
      // Draw bezier curves
      drawBezierPath();
    }
    
    // Convert canvas coordinates to field coordinates
    function canvasToFieldCoords(canvasX, canvasY) {
      // Canvas center coordinates
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // Convert to field coordinates where center is (72, 72) and bottom-left is (0, 0)
      const fieldX = 72 + (canvasX - centerX) * (144 / canvas.width);
      const fieldY = 72 - (canvasY - centerY) * (144 / canvas.height);
      
      return { x: Math.round(fieldX * 10) / 10, y: Math.round(fieldY * 10) / 10 };
    }
    
    // Check if mouse is over a control point
    function getPointUnderMouse(mouseX, mouseY) {
      for (let i = 0; i < controlPoints.length; i++) {
        const point = controlPoints[i];
        const distance = Math.sqrt((mouseX - point.x) ** 2 + (mouseY - point.y) ** 2);
        if (distance <= 8) { // 8 pixel radius for easier clicking
          return i;
        }
      }
      return -1;
    }
    
    function drawControlPoints() {
      controlPoints.forEach((point, index) => {
        // Highlight the point being dragged
        if (isDragging && index === dragPointIndex) {
          ctx.fillStyle = '#ffff00'; // Yellow when dragging
          ctx.beginPath();
          ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
          ctx.fill();
        }
        
        ctx.fillStyle = index % 4 === 0 || index % 4 === 3 ? '#ff0000' : '#00ff00';
        ctx.beginPath();
        ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
        ctx.fill();
        
        // Draw point number
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(index + 1, point.x, point.y + 4);
      });
    }
    
    function drawBezierPath() {
      if (controlPoints.length < 4) return;
      
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 3;
      ctx.beginPath();
      
      // Draw cubic bezier curves for every set of 4 points
      for (let i = 0; i <= controlPoints.length - 4; i += 3) {
        const p0 = controlPoints[i];
        const p1 = controlPoints[i + 1];
        const p2 = controlPoints[i + 2];
        const p3 = controlPoints[i + 3];
        
        if (i === 0) {
          ctx.moveTo(p0.x, p0.y);
        }
        
        ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
      }
      
      ctx.stroke();
      
      // Draw control lines
      ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
      ctx.lineWidth = 1;
      
      for (let i = 0; i <= controlPoints.length - 4; i += 3) {
        const p0 = controlPoints[i];
        const p1 = controlPoints[i + 1];
        const p2 = controlPoints[i + 2];
        const p3 = controlPoints[i + 3];
        
        // Draw control lines
        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y);
        ctx.stroke();
      }
    }
    
    // Mouse event handlers
    canvas.addEventListener('mousedown', function(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      const pointIndex = getPointUnderMouse(x, y);
      
      if (pointIndex !== -1) {
        // Start dragging existing point
        isDragging = true;
        dragPointIndex = pointIndex;
        dragOffset.x = x - controlPoints[pointIndex].x;
        dragOffset.y = y - controlPoints[pointIndex].y;
        canvas.style.cursor = 'grabbing';
      } else {
        // Add new point
        controlPoints.push({x, y});
        redrawCanvas();
      }
    });
    
    canvas.addEventListener('mousemove', function(e) {
      const rect = canvas.getBoundingClientRect();
      const canvasX = e.clientX - rect.left;
      const canvasY = e.clientY - rect.top;
      
      if (isDragging && dragPointIndex !== -1) {
        // Update dragging point position
        controlPoints[dragPointIndex].x = canvasX - dragOffset.x;
        controlPoints[dragPointIndex].y = canvasY - dragOffset.y;
        redrawCanvas();
      } else {
        // Check if hovering over a point to change cursor
        const pointIndex = getPointUnderMouse(canvasX, canvasY);
        canvas.style.cursor = pointIndex !== -1 ? 'grab' : 'crosshair';
      }
      
      // Update coordinate display
      const fieldCoords = canvasToFieldCoords(canvasX, canvasY);
      coordinatesDiv.textContent = `Coordinates: (${fieldCoords.x}, ${fieldCoords.y})`;
    });
    
    canvas.addEventListener('mouseup', function(e) {
      if (isDragging) {
        isDragging = false;
        dragPointIndex = -1;
        canvas.style.cursor = 'crosshair';
        redrawCanvas();
      }
    });
    
    // Handle mouse leave to stop dragging
    canvas.addEventListener('mouseleave', function() {
      if (isDragging) {
        isDragging = false;
        dragPointIndex = -1;
        canvas.style.cursor = 'crosshair';
        redrawCanvas();
      }
      coordinatesDiv.textContent = 'Coordinates: (-, -)';
    });
    
    // Control functions
    function clearCanvas() {
      controlPoints = [];
      redrawCanvas();
    }
    
    function exportPath() {
      const pathData = {
        controlPoints: controlPoints.map(point => {
          const fieldCoords = canvasToFieldCoords(point.x, point.y);
          return {
            canvas: {x: point.x, y: point.y},
            field: {x: fieldCoords.x, y: fieldCoords.y}
          };
        }),
        canvasSize: {width: canvas.width, height: canvas.height}
      };
      
      console.log('Path Data:', JSON.stringify(pathData, null, 2));
      alert('Path data exported to console. Check developer tools.');
    }
  </script>
</body>
</html>